//
//  TransportLayerSecurity.swift
//
//  Copyright 2021 Herald Project Contributors
//  SPDX-License-Identifier: Apache-2.0
//

import Foundation

/// Transport layer security (TLS) based on one-time secret agreed via key exchange
public protocol TransportLayerSecurity {

}

public typealias TransportLayerSecurityLocalPublicKey = Data
public typealias TransportLayerSecurityPeerResponse = Data
public typealias TransportLayerSecurityLocalResponse = Data

public class ConcreteTransportLayerSecurity {
    private let logger = ConcreteSensorLogger(subsystem: "Sensor", category: "Data.Security.ConcreteTransportLayerSecurity")
    private let pseudoRandomFunction: PseudoRandomFunction = SecureRandomFunction()
    private let keyExchange: KeyExchange
    private var sessions: [Int64:TransportLayerSecuritySession] = [:]
    private let sessionQueue = DispatchQueue(label: "Sensor.Data.Security.ConcreteTransportLayerSecurity.SessionQueue")

    public init(keyExchangeParameters: DiffieHellmanParameters = .modpGroup14) {
        self.keyExchange = DiffieHellmanMerkle(keyExchangeParameters)
    }
    
//    public func sendStartMessage() -> TransportLayerSecurityMessage {
//        let session = newSession()
//        return session.startMessage
//    }
//
//    public func receiveStartMessage(_ message: TransportLayerSecurityMessage) {
//
//    }
//
//
    
    private func newSession() -> TransportLayerSecuritySession {
        sessionQueue.sync {
            // Generate random unique id
            var id: Int64 = pseudoRandomFunction.nextInt64()
            while sessions[id] != nil {
                id = pseudoRandomFunction.nextInt64()
            }
            // Create session with new public/private key pair generated by key exchange
            let session = TransportLayerSecuritySession(id: id, keyExchange: keyExchange)
            sessions[id] = session
            return session
        }
    }
}

enum TransportLayerSecurityMessageType: UInt8 {
    case idPublicKey = 0, idPublicKeyMessage = 1, idMessage = 2
}

class TransportLayerSecurityMessage {
    let type: TransportLayerSecurityMessageType
    let id: Int32
    var data: Data { get {
        var data = Data()
        data.append(type.rawValue)
        data.append(id)
        return data
    }}
    
    init(type: TransportLayerSecurityMessageType, id: Int32) {
        self.type = type
        self.id = id
    }

    init?(data: Data) {
        guard let typeValue = data.uint8(0),
              let type = TransportLayerSecurityMessageType.init(rawValue: typeValue),
              let id = data.int32(1) else {
            return nil
        }
        self.type = type
        self.id = id
    }
}

class TransportLayerSecurityMessagePublicKey: TransportLayerSecurityMessage {
    let publicKey: KeyExchangePublicKey
    override var data: Data { get {
        var data = Data()
        data.append(super.data)
        data.append(publicKey)
        return data
    }}
    
    init(type: TransportLayerSecurityMessageType, id: Int32, publicKey: KeyExchangePublicKey) {
        self.publicKey = publicKey
        super.init(type: type, id: id)
    }

    override init?(data: Data) {
        self.publicKey = data.suffix(data.count - 5)
        super.init(data: data)
    }
}

class TransportLayerSecuritySession {
    let id: Int64
    let timestamp: Date
    let publicKey: KeyExchangePublicKey
    let privateKey: KeyExchangePrivateKey
    var peerPublicKey: KeyExchangePublicKey?
    var sharedKey: KeyExchangeSharedKey?
    var localMessage: Data?
    var peerMessage: Data?
    
    init(id: Int64, keyExchange: KeyExchange) {
        self.id = id
        self.timestamp = Date()
        (self.privateKey, self.publicKey) = keyExchange.keyPair()
    }
}
